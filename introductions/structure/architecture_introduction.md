# 架构

<!-- vim-markdown-toc Marked -->

* [1.概述](#1.概述)
* [2.架构设计的目的](#2.架构设计的目的)
* [3.架构设计的复杂度来源](#3.架构设计的复杂度来源)
    - [3.1高性能](#3.1高性能)
    - [3.2高可用](#3.2高可用)
        + [3.2.1高可用计算](#3.2.1高可用计算)
        + [3.2.2高可用存储](#3.2.2高可用存储)
        + [3.2.3高可用状态决策](#3.2.3高可用状态决策)
    - [3.3高可扩展性](#3.3高可扩展性)
    - [3.4低成本，安全，规模](#3.4低成本，安全，规模)
* [4.架构设计的三原则](#4.架构设计的三原则)
* [5.架构设计流程](#5.架构设计流程)
    - [5.1识别复杂度](#5.1识别复杂度)
    - [5.2设计备选方案](#5.2设计备选方案)
    - [5.3评估和选择备选方案](#5.3评估和选择备选方案)
    - [5.4详细方案设计](#5.4详细方案设计)
* [6.高性能数据库集群](#6.高性能数据库集群)
    - [6.1读写分离](#6.1读写分离)
    - [6.2分库分表](#6.2分库分表)
* [7.高性能NoSQL](#7.高性能nosql)
    - [7.1常见的NoSQL方案](#7.1常见的nosql方案)
    - [7.2高性能缓存架构](#7.2高性能缓存架构)
* [x.其他](#x.其他)
* [x.1架构图](#x.1架构图)
    - [x.2数据库性能优化思路步骤](#x.2数据库性能优化思路步骤)
    - [x.3常见系统与数据库选型](#x.3常见系统与数据库选型)

<!-- vim-markdown-toc -->

## 1.概述

- `系统`，相互协同可运行的实体
- `子系统`，有关联的个体组成，但是多半是更大系统的一部分
- `软件模块`, 系统从业务纬度的指责的划分，包含`程序`和`数据结构`,从`逻辑角度来拆分系统得到`,如登录模块
- `组件`，系统从技术纬度上的复用，从`物理的角度拆分得到`，如mysql, nginx等
- `框架`，为了实现业界标准或完成特定基本任务的软件组成`规范`,也指符合该规范的软件产品
- `架构`，指软件系统的`顶层结构`, 创造这些基础结构的准则以及对这些结构的描述,可以有不同的角度来区分
   - 业务逻辑角度
   - 物理部署角度
   - 开发规范角度


系统是一群关联的个体组成，个体可以是子系统，模块，组件等，架构需要明确系统包含哪些个体。

## 2.架构设计的目的

- 架构是为了应对软件系统复杂度而提出的解决方案，因此其设计目的是`为了解决软件系统复杂度带来的问题`
- 需要理解系统复杂性所在的位置
- 不必面面俱到，需要识别出复杂点针对性的解决问题
- 对别其他架构以及业务复杂点，参考复杂点相似的方案

## 3.架构设计的复杂度来源

### 3.1高性能

- `衡量性能的要素`：响应时间,tps(transaction per second)每秒事务数，服务器资源利用率等
- `高性能的目的`：追求良好的用户体验，满足业务增长的需要
- 高性能需要和业务所处的阶段相匹配，一味的追求高性能没有实际意义

如何做好高性能?

1. 垂直纬度增加单机性能
    - 增大内存，减少i/o操作
    - 使用ssd或者raid
    - 置换服务器使用获得更多的服务器或者核
    - 升级网络接口或者网络接口
2. 水平纬度
    - 功能分割，同一组件重复部署到多台不同服务器
    - 多实例副本，
    - 数据分割，每台机器上只部署一部分数据

### 3.2高可用

#### 3.2.1高可用计算

- 任务分配，双机算法：主备(冷备，热备，温备)，主主
- 高可用分类：计算高可用，存储高可用，

#### 3.2.2高可用存储

- 含义为可以`不中断的执行`其功能,各种高可用方案本质都是通过`冗余`实现
- 存储高可用领域的cap理论：存储高可用不能同时满足`一致性，可用性，分区容错性`,最多只能满足其中两个

#### 3.2.3高可用状态决策

- 高性能和高可用的基础，即系统需要判断当前的状态为正常还是异常
- 几种常见的决策方式：独裁式，协商式，民主

### 3.3高可扩展性

- 为了系统需求的变化，在未来的新需求的情况下，可以仅做少量的改动，就可支持
- 复杂点在于：不能每个设计点都考虑扩展性；不能完全不考虑扩展性
- 系统最后都要处理的问题：拆分出`变化层`和`稳定层`；需要抽象出变化层和稳定层的接口
- 良好的可扩展系统的特点：符合开闭原则(对扩展打开，对修改关闭)；对内部实现新功能的时候，对系统功能影响小；对外部，与其他系统松耦合


实际场景中的解决方案：

1. 使用分布式(服务)框架来解决，如`Dubbo`来解决
2. 使用分布式消息队列,如`rabbitmq`

### 3.4低成本，安全，规模

- 低成本：引入新技术，小公司适用；开创新的技术领域，大公司适用
- 安全：功能安全，架构安全

## 4.架构设计的三原则

- 目的：为了在比较多的选择中选取到比较适合当时业务场景的架构

1. `合适原则`，第一考虑，需要撇配当前的业务阶段
2. `简单原则`，第二考虑，如果简单的方案和复杂的方案都可以满足要求，优先使用简单方案
3. `演化原则`，第三考虑，快读落地，满足业务需要，然后在运行过程中不断演进

## 5.架构设计流程

### 5.1识别复杂度

1. 构建复杂度的来源清单，即架构的复杂度是什么引起的，如：高性能，可用性，扩展性，安全，低成本，规模等
2. 结合资源，技术，团队等对上述可能的复杂度原因逐一分析
3. 根据复杂度的优先级，越关键，优先解决

**常见系统的性能量级:**

- nginx负载均衡的性能量级在3万
- http的请求访问在2万
- zookeeper写入读取2万

### 5.2设计备选方案

- 数量上在3-5个
- 备选方案之间尽量要有明显的差异
- 备选方案不要局限于已经熟悉的技术
- 备选方案关注技术选型，不要过分关注技术细节

### 5.3评估和选择备选方案

- 列出需要关注的质量需求属性点，然后分别从这些质量属性的纬度去评估每个方案，从中挑选出合适的.
- 需求属性点包括：性能，可用性，硬件成本，项目投入，复杂性，安全性，可扩展性
- 评估这些质量属性的时候，也要根据架构设计原则，`简单原则`和`合适原则`

### 5.4详细方案设计

- 将方案设计的关键技术细节敲定

## 6.高性能数据库集群

### 6.1读写分离

- 将`访问压力`分散到集群中的多个节点，但是没有分散`存储压力`, 适合`读多写少`的问题
- 数据库服务器搭建主从集群，`一主多从`
- 主机通过复制将数据同步到从机，`每台数据库服务器存储所有的业务数据`
- 业务服务器将写操作发给数据库主机，读操作发给数据库从机
- 业务服务器-->数据库中间件-->数据库集群

两个设计复杂度：

1. `主从复制延迟`，即数据更新量大时，从机来不及复制主机的数据，导致业务问题，解决方法有：
    - 写操作后的读操作指定发给数据库主服务器
    - 读从机失败后再读一次主机, 即`二次读取`
    - 关键业务读写指向主机，非关键业务数据读写分离, 相对可取
2. `分配机制`，即如何根据读写来访问不同的数据库服务器，一般的两种方式:
    - `程序代码封装`，代码中抽象一个数据访问层，实现读写操作分离和数据库服务器连接的管理，也叫`中间层封装`，实现较简单，且可以根据业务做较多定制，但是不同语言不能通用，开源方案中较为出名的有`TDDL`
    - `中间件封装`，独立一套系统实现读写操作分离和数据库服务器连接的管理, 业务服务器直接访问中间件, 可以支持多种语言，对中间件的性能要求很高,较为出名的是`MySQL Proxy`

### 6.2分库分表

- 既可以分散访问压力，又可以分散存储压力
- `业务分库`，按照业务模块将数据分散到不同的数据库服务器
    - 导致无法使用join操作
    - 事务问题，无法通过事务统一修改
    - 成本问题
- `单表数据拆分`, 当一张表的数据过多时
    - `垂直分表`, 适合将不常用且占了大量空间的列拆分出去，如`description`等，导致的复杂性就是表操作的数量要增加, 适合对数据的操作主要集中在某些字段的业务
    - `水平分表`, 一般当表行数超过`5000万`行时使用，引入的复杂度包括：1.`路由`，需要路由算法查找数据到底属于哪个子表, 可使用有`范围路由`，`Hash路由`和`配置路由`, 适合对数据的操作在整个表面均匀分布的业务

## 7.高性能NoSQL

### 7.1常见的NoSQL方案

1. K-V存储，解决关系型数据库无法`存储数据结构`的问题，如`Redis`
    - 不支持完整的ACID事务，Redis的事务只能保证隔离性和一致性(IC)，不能保证原子性和持久性
2. 文档数据库，解决关系型数据库的`shema`约束的问题，如`MongoDB`
    - no-shema, 可以存储和读取任意的数据
    - 新增字段简单，历史数据不会出错，适合电商和游戏类场景，便于扩展新的属性
    - 最大的缺点就是不支持事务
3. 列式数据库，解决关系型数据库`大数据场景下的I/O`问题， 如`HBase`
    - 同时读取多个列时效率高
    - 能够一次性完成对一行中的多个列操作
4. 全文搜索引擎，解决关系型数据库的`全文搜索性能`问题，如`Elasticsearch`
    - 关系型数据库的全文模糊匹配用like，整表扫描，效率低
    - 技术原理为`倒排索引`，建立单词到文档的索引
    - 索引的对象为单词和文档

### 7.2高性能缓存架构

使用场景：

1. 需要经过复杂运算的场景，如统计网站当前在线户数量
2. 读多写少，存储系统无能为力

缓存设计要点：

- `缓存穿透`，缓存没有发挥作用，包括
    1. 存储数据不存在,解决方法是直接设置一个默认值
    2. 缓存数据生成耗费大量时间或者资源，典型的就是电商的分页
    3. 策略包括：双key,key的过期时间为t，key1无过期时间，每次缓存读取不到key就返回key1的内容，然后触发一个事件，该事件同时更新key和key1
- `缓存雪崩`，指缓存失效后引起的系统性能急剧下降的情况，解决方法有：
    1. `更新锁`，对缓存更新操作加锁保护，保证只有一个线程能够进行缓存更新，分布式系统还需要分布式锁
    2. `后台更新机制`，即由后台线程来更新缓存，而不是业务线程，相对更简单
- `缓存热点`，复制多分缓存副本，将请求分散到多个缓存服务器，注意不同的缓存服务器设置不同的失效时间

实现方式：程序代码实现的中间层或者独立的中间件.

缓存方案设计点：

1. 什么数据应该缓存
2. 什么时机触发缓存以及触发方式是什么
3. 缓存的层次和粒度
4. 缓存的命令规则和失效规则
5. 缓存的监控指标和故障应对方案
6. 可视化缓存如redis具体的key内容和大小

## x.其他

## x.1架构图

4 + 1视图介绍: https://blog.csdn.net/u014320421/article/details/90779353

- 逻辑视图，面向对象的设计方法时使用,是对系统职责的的逐级划分 ![tensorflow视图](./imgs/tf_logic_structure.jpg)
- 开发视图，逻辑架构元素，描述代码位置，可以是代码仓位置，或代码目录等系统的构建,这个构建信息需要包括构建依赖、构建工具链、构建环境信息
- 处理视图，描述系统的并发和同步方面的设计，对系统动态行为的描述
- 物理视图，描述软件如何映射到硬件，反映系统在分布方面的设计
- 场景视图，其他的几个视图都是以其为核心，采用UML的用例图进行设计

### x.2数据库性能优化思路步骤

1. 硬件优化，固态硬盘等
2. 数据库服务器的调优，增加索引，慢操作优化
3. 缓存的引入
4. 程序与数据库表优化，重构，减少不必要的查询
5. 最后考虑分库分表

### x.3常见系统与数据库选型

1. 管理型系统，如运营类系统，关系型数据库
2. 大流量系统，如电商单品页的某个服务，后台选关系型，前台选内存型
3. 日志型系统，原始数据使用列式，日志型选择全文搜索引擎
4. 搜索型系统，站内搜索，非通用搜索，如商品搜素，后台选关系型，前台选全文搜索引擎
5. 事务型系统，库存，交易，记账，关系型+缓存+一致性协议
6. 离线计算，大量数据分析，首选列式，或关系型
7. 实时计算，如实时监控，选时许数据库，或列式
