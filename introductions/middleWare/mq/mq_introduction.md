# mq消息队列介绍


<!-- vim-markdown-toc Marked -->

* [1.概述](#1.概述)
    - [1.1概念](#1.1概念)
    - [1.2特点](#1.2特点)
    - [1.3属性](#1.3属性)
    - [1.4模式](#1.4模式)
* [2.应用场景](#2.应用场景)
* [3.常用协议与常用消息队列](#3.常用协议与常用消息队列)
    - [3.1常用消息队列协议](#3.1常用消息队列协议)
    - [3.2常用消息队列](#3.2常用消息队列)
* [x.其他](#x.其他)
    - [x.1如何保证消息不丢失](#x.1如何保证消息不丢失)
    - [x.2如果处理重复消息？](#x.2如果处理重复消息？)
    - [x.3如何保证消息的有序性？](#x.3如何保证消息的有序性？)
    - [x.4如何处理消息堆积？](#x.4如何处理消息堆积？)

<!-- vim-markdown-toc -->

## 1.概述

- [消息中间件（一）MQ详解及四大MQ比较](https://blog.csdn.net/wqc19920906/article/details/82193316)
- [消息队列介绍](https://juejin.im/post/6844903849925459975)


### 1.1概念

- 消息队列是消息传输过程中保存消息的容器，接受消息并以文件存储，一个队列的消息可以被多个消费者使用.
- 分布式系统中的重要组件
- 当不需要立即获得结果但是要对并发进行控制的时候使用

### 1.2特点

- 系统`解耦，异步，削峰`
- 提高系统响应时间
- 为大数据处理架构提供服务

### 1.3属性

1. 消息顺序，普通队列支持两种
    - `分区有序`, 分布式处理之后支持更高的并发，但是处理消息的时候可能是无序的，如果需要有序可以在每条消息中添加排序信息
    - `全局队列`, 消息遵循先进先出，适用于需要严格顺序的场景
2. 至少一次传递,当用户多次接收同一个消息的时候，应用程序不得有不利的影响
3. 消息较少时，单次消费不能获取指定数量的消息

### 1.4模式

1. 点对点模式, 三个角色
    - `消息队列`，接收者在成功接收消息之后需向队列应答成功，以便消息队列删除当前接收的消息
    - `发送者 (生产者)`, 发送者和接受者之间没有依赖性，不管有没有接收者在运行，都不会影响到发送者下次发送消息
    - `接收者（消费者）`, 每个消息只有一个接受者
    -消息发送者生产消息发送到queue中，然后消息接收者从queue中取出并且消费消息。消息被消费以后，queue中不再有存储，所以`消息接收者不可能消费到已经被消费的消息`
2. 发布/订阅模式
    - `角色主题（Topic）`
    - `发布者(Publisher)`,发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息
    - `订阅者(Subscriber)`, 每个消息可以有多个订阅者, 为了消费消息，订阅者需要提前订阅该角色主题，并保持在线运行

## 2.应用场景

1. 异步处理
    - eg: 用户注册的时候发送验证短信和邮件的时候,任务写入消息队列就立即返回结果，大大提高响应速度
2. 解耦
    - eg: 上传图片然后进行检测，将图片上传与检测结偶，上传图片的信息写入消息队列，图片检测则定时从消息队列中取出图片检测
3. 冗余，将数据持久化直至其被处理，不会因为数据处理过程失败而丢失数据
4. 扩展性，便于分布式扩容
5. 过载保护
6. 可恢复性，一个处理消息的进程挂掉，仍可以被其他进程处理
7. 顺序保证
8. 缓冲，可以优化控制数据流经系统的速度
    - eg: 秒杀系统中，请求先入消息队列，而不是直接处理业务
9. 数据流处理，业务日志，监控数据，用户行为等数据流实时或者批量采集汇总
10. 消息驱动的系统，前一个阶段处理完成的结果，后一个阶段直接取出来处理

## 3.常用协议与常用消息队列

### 3.1常用消息队列协议

- `AMQP`，提供统一消息服务的应用层标准高级消息队列协议，面向消息，可靠，通用
- `MQTT`，支持所用平台，物联网，占用带宽小
- `STOMP`，流文本定向消息协议
- `XMPP`，可扩展消息处理现场协议
- 其他

### 3.2常用消息队列

1. RocketMQ
   - 分布式，队列模型
2. RabbitMQ
   - 支持多协议, [介绍](./rabbitmq_introduction.md)
   - 重量级，适合企业级开发,使用较多
   - 采用物理隔离的方式部署
3. ActiveMQ
    - 使用amqp协议，简单易用
    - 支持水平扩展
4. Redis
5. Kafka
    - 支持`高吞吐`和`高可靠`两种模式
    - 高吞吐模式的消息副本异步落盘，具有较高的性能
    - 高可靠模式的消息多副本同步落盘，保证消息的可靠性
6. ZeroMQ
7. 普通队列
    - 包括分区有序和全局有序

## x.其他

### x.1如何保证消息不丢失

在三个阶段分别保证：

1. 生产阶段, 做好try-catch，生产者发送消息到broker需要处理好异常，妥善处理
2. 存储阶段，在`消息刷盘`之后再返回响应，如果消息是集群部署的，则需要将消息写入副本机器中之后再响应
3. 消费消息，在消费者真正执行完业务逻辑之后，再发送给Broker消费成功，这才是真正的消费了

### x.2如果处理重复消息？

正常业务而言消息重复是不可避免的，只能从业务上来处理, 关键是处理`幂等，即同样的参数多次调用同一个接口和调用一次产生的结果是一致的`，
需要改造业务处理逻辑，使得在重复消息的情况下也不会影响最终的结果。

1. 前置条件控制
2. 数据库约束，如唯一键或者关键的key，处理之前判断是否之前已经处理过了

### x.3如何保证消息的有序性？

1. 全局有序：一个生产者往Topic发送消息，并且一个Topic内部只能有一个队列（分区）。消费者也必须是单线程消费这个队列。这样的消息就是全局有序的
2. 部分有序：可以将Topic内部划分成我们需要的队列数，把消息通过特定的策略发往固定的队列中，然后每个队列对应一个单线程处理的消费者

### x.4如何处理消息堆积？

消息堆积原因：生产者的生产速度与消费者的消费速度不匹配。有可能是因为消息消费失败反复重试造成的，也有可能就是消费者消费能力弱

1. 如果是bug，则处理bug，优化逻辑
2. 逻辑优化还是慢，则可以考虑水平扩容，增加topic队列数和消费者数

