# go语言基础知识

<!-- TOC -->

- [go语言基础知识](#go语言基础知识)
    - [1.学习资源](#1学习资源)
    - [2.基础概念](#2基础概念)
        - [2.1 GOPATH规则](#21-gopath规则)
        - [2.2基本命令](#22基本命令)
        - [2.3基础语法](#23基础语法)
        - [2.3.1命名](#231命名)
        - [2.3.2其他](#232其他)
        - [2.3.4符号](#234符号)
    - [3.数据类型](#3数据类型)
        - [3.1布尔型 bool](#31布尔型-bool)
        - [3.2数字型 float32, float64](#32数字型-float32-float64)
        - [3.3字符串类型](#33字符串类型)
        - [3.4nil类型](#34nil类型)
        - [3.5派生类型](#35派生类型)
        - [3.5接口](#35接口)
    - [4.变量与常量以运算](#4变量与常量以运算)
        - [4.1变量定义](#41变量定义)
        - [4.2常量定义](#42常量定义)
        - [4.3运算符](#43运算符)
    - [5.函数](#5函数)
        - [5.1声明一个函数](#51声明一个函数)
        - [5.2函数作为一个实参](#52函数作为一个实参)
        - [5.3数据结构创建函数](#53数据结构创建函数)
    - [6.基础语句](#6基础语句)
        - [6.1条件语句](#61条件语句)

<!-- /TOC -->

## 1.学习资源

[go语言入门教程](http://c.biancheng.net/golang/)
[go语言中文网](https://studygolang.com/)

## 2.基础概念

1. 可以直接编译为机器码
2. 静态数据类型和编译语言
3. 内置支持并发
4. 内置垃圾回收
5. 部署简单
6. 强大的标准库

package（包）:

- 同一个包下文件属于同一个工程文件，不必import，可直接使用
- 同一个包下面所有文件package名字一样
- 同一个包下面的文件package名字建议为目录名字，也可以不是

```go
// import点操作, 含义是导入之后调用的时候可以省略前缀包名
import (
    . "fmt"
)

// 别名操作,将包重命名
import (
    f "fmt"
)

// _操作，引入该包，但是不直接使用里面的函数，而是调用了该包的init函数
import (
    _ "github.com/ziutek/mymysql/godrv"
)
```

### 2.1 GOPATH规则

api：每个版本的 api 变更差异
bin：go 源码包编译出的编译器（go）、文档工具（godoc）、格式化工具（gofmt）
blog：Go 博客的模板，使用 Go 的网页模板，有一定的学习意义
doc：英文版的 Go 文档
lib：引用的一些库文件
misc：杂项用途的文件，例如 Android 平台的编译、git 的提交钩子等
pkg：Windows 平台编译好的中间文件
src：标准库的源码
test：测试用例

### 2.2基本命令

```shell
# 将文件直接编译为机器码
go build hello.go
# 执行命令
go run hello.go
# 查看版本
go version
# 查看环境
go env
# 查看当前目录中所有可用包
go list
# 清空生成的可执行文件
go clean
# 从远程下载第三方的库至GOPATH
go get
# 查看包或者函数的源码的api
go doc [package] [function]
# 对文件进行格式化
gofmt hello.py
```

### 2.3基础语法

### 2.3.1命名

`某个名称在包外是否可见，就取决于其首个字符是否为大写字母.`

1. 包名：`包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法`;`包名应为其源码目录的基本名称`;
2. 获取器名：当一个包被导入后，包名就会成了内容的访问器。
3. Go中约定使用驼峰记法 MixedCaps 或 mixedCaps。

### 2.3.2其他

1. Go的正式语法使用分号来结束语句，词法分析器会使用一条简单的规则来自动插入分号，因此因此源码中基本就不用分号
2. `不再使用 do 或 while 循环，只有一个更通用的 for`
3. `if 和 switch 像 for一样可接受可选的初始化语句`

### 2.3.4符号

1. `:=`：短声明
2. 遍历数组、切片、字符串或者映射，或从信道中读取消息,用range

```go
for i := 0; i < 10; i++ {
    sum += i
}
```

```go
for key, value := range oldMap {
    newMap[key] = value
}
```

## 3.数据类型

变量的声明我们可以通过var关键字，然后就可以在程序中使用。当我们不指定变量的默认值时，这些`变量的默认值是他们的零值`。

### 3.1布尔型 bool

### 3.2数字型 float32, float64

### 3.3字符串类型

### 3.4nil类型

- 空值
- 任何类型在未初始化时都对应一个零值：布尔类型是false，整型是0，字符串是""，而指针，函数，interface，slice，channel和map的零值都是`nil`

### 3.5派生类型

1. 指针类型(Pointer)
2. 数组类型
3. 结构化类型(struct)
4. Channel类型
5. 函数类型
6. 切片类型(动态数组)
7. 接口类型(interface)
8. Map类型(集合,无序键值对)

```go
// 创建map集合的两种方式
var m1 map[string]string
m2 = make(map[string]string)
```

### 3.5接口

所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。

`注意`：

1. 接口内只实现了函数的声明,没有实现
2. 接口中只能有方法的声明, 不能有变量的声明
3. 只要某种数据类型实现了接口, 那么就可以使用接口变量保存这种数据类型
4. 只要某种数据类型实现了接口, 那么就可以使用接口变量调用接口中声明的方法
5. 实现一个接口, 不需要做额外的声明, 只要某种数据类型绑定了所有接口中的方法就是实现了这个接口
6. 只有实现了接口中声明的所有方法, 才算实现了接口, 才能使用接口变量保存
7. 在实现接口的时候, 方法名称,形参列表,返回值列表必须一模一样

## 4.变量与常量以运算

### 4.1变量定义

- 不可以再次对于相同名称的变量使用初始化声明
- 声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误

```go
// 单变量声明
// 1.指定变量类型，不赋值则为默认值
var name type
name = value
// 2.自行判断变量类型
var name = value
// 3.省略var,但是 := 左侧的变量不应该为声明过的，否则编译错误
c := 10

// 多变量声明
// 1.逗号分隔，声明赋值分开,不赋值则给默认值
var name1, name2 type
name1, name2 = value1, value2
// 2.直接赋值，可以是不同类型
var name1, name2 = value1, value2
// 3.集合类型
var (
    name1 type
    name2 type
)
```

### 4.2常量定义

- 不曾使用的常量，在编译的时候，是不会报错的
- 特殊常量`iota`,一个可以被编译器修改的常量，每一个const出现被重置为0,在下一个const出现之前，其所代表的数字会自增1

```go
// 1.显示定义
const a string = "ha"
// 2.隐式定义
const b = "ha"
// 用作枚举
const (
    UNKNOWN = 0
    MALE = 1
    FEMALE = 2
)
```

### 4.3运算符

1. 算术运算：`+ - * / %(求余) ++ --`
2. 关系运算：`== != > < >= <=`
3. 逻辑运算：`&& || !`
4. 其他 TODO:

## 5.函数

`注意`：

1. Go语言中的函数可以和任何类型绑定, 但是一般用于和结构体绑定.
2. 定义一个结构体,将函数和结构体绑定在一起的东西就是方法
3. 方法和函数的区别在于, 函数可以直接调用(通过包名.函数名称), 而方法只能通过绑定的数据类型对应的变量来调用(变量.函数名称)
4. 函数名称和方法名称可以重名

### 5.1声明一个函数

```go
// 后一个int表明返回值得类型
func max(num1, num2 int) int {
    if num1 > num2 {
        return num1
    } else {
        return num2
    }
}
```

### 5.2函数作为一个实参

函数作为实参，可以实现回调。

### 5.3数据结构创建函数

`new`:

- 动态分配一个空间，只需要使用，不必考虑内存释放其生命周期
- 只接受一个参数，这个参数是一个类型
- 分配好内存之后，返回一个指向该类型内存地址的指针，同时将分配的内存置为0
- 不常用

```go
i = new(int)
a := new(Student)
```

`make`:

- 同样用于内存分配
- 只用于chan, map以及切片的内存创建
- 返回的类型就是类型本身，而不是指针类型

```go
// 创建了一个有10个元素的Slice对象
var v []int = make([]int, 10)
```

## 6.基础语句

### 6.1条件语句

```go
// if
if 布尔表达式 {
   /* 在布尔表达式为 true 时执行 */
} else {
  /* 在布尔表达式为 false 时执行 */
}

// switch
switch var1 {
    case val1:
        ...
    case val2:
        ...
    default:
        ...
}

// type switch,判断某个interface变量中实际存储的变量类型
var x interface{}
switch i := x.(type) {
    case nil:
        fmt.Printf(" x 的类型 :%T",i)
    case int:
        fmt.Printf("x 是 int 型")
    default:
        fmt.Printf("未知型")

// select语句，类似switch,随机执行一个case,没有case执行则会阻塞至有case执行
// 每个case都必须是一个通信
// 所有channel表达式都会被求值
// 所有被发送的表达式都会被求值
// 如果任意某个通信可以进行，它就执行；其他被忽略。
// 如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。
// 否则：
// 如果有default子句，则执行该语句。
// 如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。
var i1, int
var c1 chan int
select {
    case i1 = <-c1:
        fmt.Printf("received ", i1, " from c1\n")
    default:
        fmt.Printf("no communication\n")
```
