# 简单秒杀系统设计

<!-- vim-markdown-toc Marked -->

* [1.概述](#1.概述)
    - [1.1参考](#1.1参考)
    - [1.2介绍](#1.2介绍)
* [2.基础架构](#2.基础架构)
    - [2.1订单请求](#2.1订单请求)
    - [2.2订单队列](#2.2订单队列)
    - [2.2唯一标识](#2.2唯一标识)
    - [2.4超时队列](#2.4超时队列)
    - [2.5支付请求](#2.5支付请求)
    - [2.6整体流程](#2.6整体流程)

<!-- vim-markdown-toc -->

## 1.概述

### 1.1参考

- python + redis + rabbitmq + flask
- [简书:高并发抢购系统架构搭建](https://www.jianshu.com/p/ef6d25397f04)
- [知乎: 如何设计一个秒杀系统](https://www.zhihu.com/question/54895548)

### 1.2介绍

- 普通系统的瓶颈：底层的数据库端，由于磁盘读写io较慢，且连接数有限
- 秒杀系统常见问题：
    - `高并发`
    - `超卖`
    - `恶意请求`
    - `链接暴露`
    - `数据库`
- 秒杀场景
    - 特点为`瞬时高并发`，短时间有大量的请求
    - 如果所有请求都到底层数据库，数据库会崩溃，或者大量的读写请求造成大量的锁冲突，导致响应速度变慢
    - 明确目标：`让尽可能少、尽可能有效的请求打到底层数据库`
- 网站设计的角度，第二个目标：越上层越容易实现，越有效, 包括：
    - `页面层`, 前端页面将用户点击后的按钮置灰，避免多次点击发送请
    - `网络层`，通过ip限制一定时间内部请求次数(nginx可以通过`HttpLimitReqModul`和`HttpLimitZoneModule`配置来限制ip在同一时间段的访问次数)
    - `应用层`, 动静分离，压缩缓存处理(CDN，nginx)；根据uid限频，页面缓存技术；反向代理+负载均衡
    - `服务层`, 微服务，redis, 消息队列
    - `数据层`, 读写分离，分库分表，集群

## 2.基础架构

- 核心：服务异步拆分，减少耦合，使用缓存加快响应
- 避免请求同步执行：如：请求→订单→支付→修改库存→结束返回，使用1. 请求→返回 2. 支付→返回 3. 修改库存 模型代替
- 基础数据存储：
    - mysql中存储订单信息，商品数据信息
    - redis存入商品信息、设置计数器、存储成功订单的数据结构等
    - rabbitmq创建队列: `订单队列`（用户提交请求）; `延迟队列`（订单必须在15分钟内支付）; `成交队列`（订单支付成功，等待写入数据库）

### 2.1订单请求

- 使用redis计数器，指定请求的数量不会超过预期

### 2.2订单队列

- 将请求订单任务保存，就可以直接返回用户

### 2.2唯一标识

- 标识订单
- 返回给用户，用于后续的支付操作

### 2.4超时队列

- 指定时候内付款支付

### 2.5支付请求

- 检查订单号的正确性
- 订单是否超时
- 支付成功入成交队列
- 将成交订单写入redis,记录状态，等抢购活动结束后，系统比较空闲的时间将订单同步到底层数据库，同步数据

### 2.6整体流程

1. 用户提交订单
    通过redis计数器筛选: 成功则返回标识，然后入订单队列 + 超时队列
    标识与用户信息写入redis，用于后续验证支付
    订单队列，mysql监听，写入mysql的订单历史表
    超时订单队列有计时功能，一定时间内未支付，订单失效，抢购失败。写入redis（标志失败）
    失败直接返回
2. 订单服务结束
3. 用户支付订单
    验证订单以及检查是否已超时（是否已在redis相关结构内）
    成功支付则入支付队列
    mysql监听这个队列，执行库存同步操作
    写入redis
    失败或超时直接返回
4. 支付服务结束

