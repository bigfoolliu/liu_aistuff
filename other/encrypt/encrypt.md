# 数据加密相关知识

5LuW5b6I5bm46L+Q77yM55yf55qE77yM5bCx5ZKM5b2T5Yid55qE5oiR5LiA5qC35bm46L+Q

## 1.base64编转码

## 1.1介绍

[base64参考链接](https://www.liaoxuefeng.com/wiki/897692888725344/949441536192576)

base64是一种用64个字符来表示任意二进制数据的方法，实际上并`不属于加密范畴`。

### 1.2编码原理

1. 准备包含64个字符的数组
   `["A", "B", "c", ..., "+"]`
2. 对将要编码的二进制数据处理，每3个字节为一组，每组$3 * 8 = 24bit$
3. 将该组分为4小组，每小组$24 / 4 = 6bit$
4. 将该4小组每小组头部增加两位`00`，得到一个字节，因此共4个字节
5. 4个字节中的有效位为`2^6=64`,此为64的来历
6. 在6个有效位对应准备好的64个字符，逐一对应编码
7. 完成对原始数据的编码
8. 解码的过程逆向即可

注意：
由于是3个字节增加为4个字节，所以有可能到末尾的时候为剩余1个或2个字节，此时：

- 不足6bit的时候结尾补0，直到6bit
- 完全没有分配的时候，直接使用`=`

base64编码转换图：

![base64编码转换图](./images/base64编码对照表.png)

### 1.3代码示例

[base64_demo](./codes/base64/base64_demo.py)

## 4.RSA加密（非对称加密）

[参考资料](https://www.cnblogs.com/cjm123/p/8243424.html)

### 4.1数学背景介绍

**`欧拉函数`**：任意给定正整数n，欧拉函数$\phi(n)$是小于或等于n的正整数中与n互质的的数的数目：$$\phi(n)= \displaystyle \prod_{k=1}^{\infty} (1 - n^k)$$

示例：1~8中与8互质的有1, 3, 5, 7, 因此$\phi(8) = 4$

**`欧拉定理`**：如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：$$a^{\phi(n)} \equiv 1(mod(n))$$
即a的φ(n)次方被n除的余数为1。

**`模反元素`**：两个正整数a, n互质，那么一定可以找到正整数b，使得$ab-1$被n整除，此时，b叫a的模反元素。$$ab \equiv 1(mod(n))$$

### 4.2加密原理(密钥生成原理)

1. A随机选择两个不等的质数(数值越大则越难破解)
   $p = 61$
   $q = 53$
2. 计算乘积
   $61 * 53 = 3233 = n$
3. n的长度就是秘钥的长度
   $3233 ‭= 0b‭110010100001‬$
   秘钥长度为12位
4. 计算n的欧拉函数(公式成立要到[中国剩余定理](https://en.wikipedia.org/wiki/Chinese_remainder_theorem))
   $\phi(n)=(p-1)(q-1)=60*53=3120$
5. 选择一个随机整数e, $1 < e < \phi(n)$，且e与$\phi(n)$互质，比如
   $e = 17$
6. 计算e对于$\phi(n)$的模反元素d，即
   $ed \equiv 1(mod(\phi(n))$
   -->$ed - 1 = mod(\phi(n))$
   -->$17d - 1 = 3120k$
7. 得到其中一组解(使用[扩展欧几里得法](https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95))
   $d = 2753$
   $k = 15$
8. 最终6个数字为：
   $p = 61$
   $q = 53$
   $n = 3233$
   $\phi(n) = 3120$
   $e = 17$
   $d = 2753$
9. 将$(n, e)$封装为公钥，$(n, d)$封装为私钥，即
    公钥: $(3233, 17)$
    私钥: $(3233, 2753)$
10. 实际的公钥和私钥的格式被称为**ASN.1(抽象语法标记)**格式

总结：破解私钥就是找到**d**的值
-->找到d需要知道e和$\phi(n)$
-->找到$\phi(n)$需要知道p和q，即**将n进行因式分解**
一旦n的值足够大的时候，除暴力破解，几无它法。（目前破解的最大的n的长度为768，实际中一般使用1024位）

### 4.3加解密过程

假如需要加密的数据为 m(**m必须为整数，字符串可以为ascii值或者unicode值，且m必须小于n**)

*当需要m的值大于m时可以使用方案：*

- *长信息分割成若干段短消息，每段分别加密*
- *先选择一种"对称性加密算法"（比如DES），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥*

1. 使用公钥$(3233, 17)$加密
2. 计算等式
   $$m^e \equiv c(mod(n))$$
   假设：$m = 65$
   --> $65^{17} = 2790(mod3233)$
   --> $c = 2790$
   --> c就是加密后的数据
3. 使用私钥$(3233, 2753)$解密
4. 首先有恒等式：
   $c^d \equiv m(mod(n))$
   --> $2790^{2753} = 65(mod(3233))$
5. 解密出原文为
   $m = 65$
6. 加解密过程完成，可以看出没有d的值，就不能根据c算出m

### 4.4代码示例

[rsa_demo](./codes/rsa/rsa_demo.py)

### 4.5相关应用

[数字证书原理](https://www.cnblogs.com/franson-2016/p/5530671.html)
