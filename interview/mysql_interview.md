# mysql面试

<!-- TOC -->autoauto- [mysql面试](#mysql面试)auto    - [1.mysql基础使用及命令](#1mysql基础使用及命令)auto    - [2.索引相关](#2索引相关)auto        - [2.1基础概念](#21基础概念)auto        - [2.2mysql索引类型](#22mysql索引类型)auto            - [2.2.1哈希索引](#221哈希索引)auto            - [2.2.2B+树索引](#222b树索引)auto        - [2.3联合索引](#23联合索引)auto        - [2.4建立索引考虑要素](#24建立索引考虑要素)auto        - [2.5判断索引是否被使用](#25判断索引是否被使用)auto        - [2.6查询不会使用索引的情况](#26查询不会使用索引的情况)auto    - [3.事务相关](#3事务相关)auto        - [3.1事务介绍](#31事务介绍)auto        - [3.2事务隔离级别产生原因](#32事务隔离级别产生原因)auto            - [3.2.1锁](#321锁)auto            - [3.2.2锁的类型](#322锁的类型)auto            - [3.2.3锁的粒度](#323锁的粒度)auto            - [3.2.4死锁](#324死锁)auto            - [3.2.5乐观锁和悲观锁](#325乐观锁和悲观锁)auto        - [3.3事务隔离级别](#33事务隔离级别)auto        - [3.4 MVCC](#34-mvcc)auto    - [4.表结构设计](#4表结构设计)auto        - [4.1主键](#41主键)auto        - [4.2NULL与NOT NULL](#42null与not-null)auto        - [4.3用户密码散列用什么类型存储](#43用户密码散列用什么类型存储)auto    - [5.存储引擎相关](#5存储引擎相关)auto        - [5.1mysql支持哪些引擎及其区别](#51mysql支持哪些引擎及其区别)auto    - [6.查询相关](#6查询相关)auto        - [6.1多表联合查询](#61多表联合查询)auto        - [6.2内连接](#62内连接)auto        - [6.2外连接](#62外连接)auto    - [7.零散](#7零散)auto        - [7.1char与varchar的区别](#71char与varchar的区别)auto        - [7.2varchar(10)与int(10)的区别](#72varchar10与int10的区别)auto        - [7.3binlog的录入方式与区别](#73binlog的录入方式与区别)auto        - [7.4超大分页的处理](#74超大分页的处理)auto        - [7.5业务中sql的耗时以及慢查询优化](#75业务中sql的耗时以及慢查询优化)auto        - [7.6横向分表和纵向分表的例子](#76横向分表和纵向分表的例子)auto        - [7.7什么是存储过程及其优缺点](#77什么是存储过程及其优缺点)auto        - [7.8三个范式](#78三个范式)auto        - [7.9mybatis中的#与$的区别](#79mybatis中的与的区别)auto        - [7.10E-R图](#710e-r图)auto        - [7.11mysql单表多次查询与多表联合查询效率对比](#711mysql单表多次查询与多表联合查询效率对比)autoauto<!-- /TOC -->

- [mysql高频一百问](https://juejin.im/post/5d351303f265da1bd30596f9?utm_source=gold_browser_extension#heading-2)
- [mysql索引原理及其优化](http://huyan.couplecoders.tech/mysql/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDmysql/2019/06/01/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/))
- [一文搞懂Mysql事务隔离级别](http://huyan.couplecoders.tech/mysql/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDmysql/2019/06/07/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/)

## 1.mysql基础使用及命令

- [mysql必知必会](../books/mysql必知必会/mysql_known.md)

## 2.索引相关

- [mysql索引背后的数据结构和算法](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

### 2.1基础概念

**索引是存储引擎用于快速查找到记录的数据结构。**

优点:

- 加快了记录的查询
- 减少了服务器的排序操作和创建临时表的操作
- 将随机I/O变为`顺序I/O`

缺点：

- 占用了额外的储存空间
- 因为需要维护，减慢了插入以及更新记录速度

### 2.2mysql索引类型

1. B-/B+树索引(`mysql默认使用B+树`，但是`实现上又会区分为聚簇索引和非聚簇索引`)
2. 哈希索引
3. 全文索引
4. 空间数据索引

#### 2.2.1哈希索引

底层实现就是hash表，调用一次hash函数就可以找到键值，然后由键值表找到记录。

- 等值查询较快，但是性能不稳定
- 不支持使用索引进行排序，不支持模糊查询

#### 2.2.2B+树索引

底层实现是`多路平衡查找树`，每次查找从根节点出发，到叶子节点得到键值，找到记录。

- `聚簇索引`：叶子节点只存储了当前的key值
- `非聚簇索引`：叶子节点存储了当前的key值以及整行的数据

InnoDB中：

- `默认使用主键建立聚簇索引`
- 没有主键使用唯一键建立聚簇索引
- 没有唯一键，隐式的生成一个键建立聚簇索引

### 2.3联合索引

- **同时使用多个字段建立的索引叫作联合索引。**
- **联合索引想要命中需要按照建立索引的顺序挨个使用，否则无法命中索引。**

### 2.4建立索引考虑要素

- 字段使用频率高的适合作为索引
- 联合索引(即多个字段的索引)还需要考虑联合索引中的顺序

### 2.5判断索引是否被使用

- explain分析sql语句执行计划可以得到是否使用索引
- [mysql的explain语句详解](https://www.cnblogs.com/tufujie/p/9413852.html)

### 2.6查询不会使用索引的情况

- 使用不等于查询
- 列参与了数学运算
- 其他

## 3.事务相关

### 3.1事务介绍

**事务是一系列不可分割的操作，要么全部成功，要么全部失败。**

需要符合四个特征：

1. `原子性(A)`,即要么全部成功，要么全部失败
2. `一致性(C)`,即db只会从一个一致性状态到另一个一致性状态，不会有中间态
3. `隔离性(I)`,即一个事务在执行完成之前对其他事务是不可见的
4. `持久性(D)`,即事务一旦提交，不会改变

### 3.2事务隔离级别产生原因

**事务隔离级别的产生是为了控制并发。**

#### 3.2.1锁

当数据读取与数据写入产生冲突的时候，锁产生。

#### 3.2.2锁的类型

1. `读锁`，属于`共享锁`，可以多个同时存在，因为多个读取操作不会产生冲突
2. `写锁`，属于`排他锁`，会排斥其他的读锁或者写锁

#### 3.2.3锁的粒度

锁的粒度即`锁作用的范围`，因为数据的读取和写入如果不是同一个数据的时候，频繁加锁会影响性能。

1. `表锁`，对操作的表加锁，开销较小
2. `行级锁`，对操作的数据行加锁，开销较大

#### 3.2.4死锁

- 死锁是一种状态的描述
- 两个操作占有自己的`资源不释放`，然后请求对方的资源造成的状态

解决方式：**Innodb将持有最少行数排他锁(写锁)的事务进行回滚来打破。**

#### 3.2.5乐观锁和悲观锁

- [mysql乐观锁介绍](https://blog.csdn.net/aodaidi6752/article/details/101595344)
- [mysql悲观锁总结和实践](https://www.iteye.com/blog/chenzhou123520-1860954)

**乐观锁：**

- 假设认为数据一般情况下不会发生冲突，所以在数据提交更新的时候才会去检查是否冲突
- 如果冲突了就会返回错误信息，让用户决定怎么做

**悲观锁：**

- 认为数据一般情况下会发生冲突，所以在整个数据处理的过程中都会将数据锁定，不被外界锁修改

### 3.3事务隔离级别

**事务的实现会增加性能开销，事务隔离级别是对事务实际情况选取不同的策略，从而提高性能。**

事务隔离级别种类：

1. `未提交读`，使用较少，即`未提交就可以读`，其他事务可以看到本事务没有提交的更改，可能会造成`脏读`，即读取到的数据是不正确的脏数据
2. `已提交读`，其他事务只能读取到本次事务提交的部分，存在`不可重复读`的问题，[mysql事务的不可重复读演示](https://blog.csdn.net/nangeali/article/details/75578605)
3. `可重复读`，`Inndodb默认级别`，解决了不可重复的的问题，但是可能会产生`幻读`问题，[mysql可重复读现象已经原理](https://www.2cto.com/database/201807/763885.html)
4. `可串行化`，最高的隔离级别，较少使用，强制将所有的操作串行化，导致并发性能下降

### 3.4 MVCC

**相对于锁的另一种控制并发的方式，核心思想是为每一条数据加两个版本号:`数据的删除版本号`和`数据的当前版本号`**

## 4.表结构设计

### 4.1主键

- 保证数据行的唯一性
- 尽量使用自增长id而不是uuid,innodb中主键索引作为聚簇索引，如果是自增id,叶子节点排序时只要依次就行，减小开销

### 4.2NULL与NOT NULL

- [为什么mysql列属性尽量使用NOT NULL](https://www.cnblogs.com/sherlockwhite/p/why_not_null.html)
- NULL使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。

### 4.3用户密码散列用什么类型存储

**密码散列,盐,用户身份证号等固定长度的字符串应该使用char而不是varchar来存储,这样可以节省空间且提高检索效率。**

## 5.存储引擎相关

### 5.1mysql支持哪些引擎及其区别

| 存储引擎 | 事务 | 锁 | MVCC | 外键 | 全文索引 |
| ------- | ---- | -- | ---- | ---- | ------- |
| InnoDB | 支持 | 支持行级锁 | 支持  | 支持 | 不支持 |
| Myisam | 不支持 | 支持表级锁 | 不支持 | 不支持 | 支持 |
| Memory |  |  |  |  |  |
| Archive |  |  |  |  |  |

## 6.查询相关

### 6.1多表联合查询

- [mysql多表联合查询，子查询，连接查询](https://blog.csdn.net/weixin_39411321/article/details/90602030)

### 6.2内连接

- 表间的外键和主键相连，只取键值一致的。

```shell
select 列名1 from 表1 left outer join 表2 on 表1.外键=表2.主键 where 条件语句;
```

### 6.2外连接

- 只能取得一方的数据
- 分为`左外连接(以左表为标准)`和`右外连接(以后表为标准)`

```shell
# 左外连接
select 列名1 from 表1 left outer join 表2 on 表1.外键=表2.主键 where 条件语句;
# 右外连接
select 列名1 from 表1 right outer join 表2 on 表1.外键=表2.主键 where 条件语句;
```

## 7.零散

### 7.1char与varchar的区别

- char是定长字段,且最长可以存储255字
- varchar是变长字段，且最长可存储65532字符
- 检索效率上char > varchar

### 7.2varchar(10)与int(10)的区别

- varchar(10)表示申请的空间长度为10，是可以存储的空间的最大值
- int(10)表示的是展示的长度，不足10位用0填充，int(1)和int(10)占用的空间相同

### 7.3binlog的录入方式与区别

- [mysql的binlog使用总结](https://blog.csdn.net/zhenhuax/article/details/81295412)

录入方式：

1. `statement`,该模式会记录每一个sql语句造成的影响
2. `row`，该模式会记录每一行的改动，日志量偏大
3. `mixed`，该模式为以上两种折中方案，普通操作用statement,无法使用时用row

### 7.4超大分页的处理

- [后端分页查询总结](https://blog.csdn.net/qq_37465368/article/details/81315834)

- 数据库层面，`先做快速定位需要获取的id段，然后再关联`(select * from tab1 where id in (select id from tab1 where age > 20 limit 100000,20))
- 需求层面，不做这种类似的需求

### 7.5业务中sql的耗时以及慢查询优化

慢查询的原因：

- load多余的列或者数据，则重写sql语句
- 分析语句的执行计划，获得其索引的执行情况，可以优化索引或者修改语句使其尽可能的命中索引
- 考虑是否表中的数据量是否太大，将表拆分

### 7.6横向分表和纵向分表的例子

横向拆分：按行拆分，比如一张一亿用户的表，根据用户id尾号0-99拆分为100张表
纵向拆分：按列拆分，比如新闻表，内容较占用空间，将其单独拆分

### 7.7什么是存储过程及其优缺点

- [mysql存储过程](https://blog.csdn.net/wzhJava_Only/article/details/87712005)
- [mysql存储过程实战](https://blog.csdn.net/liu16659/article/details/81708908)

是一组`预编译好的sql语句集合，类似于批处理文件`，实际不推荐使用，因为管理起来不方便。

优点：

1. 提高代码的重用性
2. 简化了操作
3. 减少了编译与连接服务器的次数，提高了效率

### 7.8三个范式

**数据库设计三大范式**：

1. 每一列都具有原子性, 即不可再分割
2. 属性必须完全依赖主键
3. 所有的非主属性不能依赖其他非主属性

### 7.9mybatis中的#与$的区别

- [深入浅出MyBatis-快速入门](https://blog.csdn.net/hupanfeng/article/details/9068003)

- `#`将传入的内容当做字符串，可一定预防sql注入
- `$`将传入的内容直接拼接到sql语句中

### 7.10E-R图

- [E-R图的基本概念](https://blog.csdn.net/chenpidaxia/article/details/62073162)
- [数据库设计之概念设计—ER图详解](https://blog.csdn.net/zxq1138634642/article/details/9121363)

### 7.11mysql单表多次查询与多表联合查询效率对比

- [MySQL多表关联查询效率高点还是多次单表查询效率高，为什么？](https://www.zhihu.com/question/68258877)

`总体来说多次单表用的比较多一些。`
