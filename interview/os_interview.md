# 操作系统面试

<!-- TOC -->

- [操作系统面试](#操作系统面试)
    - [1.进程](#1进程)
    - [2.线程](#2线程)
    - [3.协程](#3协程)
    - [4.内存管理](#4内存管理)
        - [4.1栈](#41栈)
        - [4.2堆](#42堆)
        - [4.3内存抖动](#43内存抖动)
    - [5.磁盘](#5磁盘)
        - [5.1磁盘调度](#51磁盘调度)
    - [6.高并发](#6高并发)
        - [6.1提升系统并发能力](#61提升系统并发能力)
        - [6.2高并发指标](#62高并发指标)
        - [6.3python解决高并发](#63python解决高并发)
        - [6.4并发模型](#64并发模型)
            - [6.4.1多线程编程模型](#641多线程编程模型)
            - [6.4.2Callback编程模型](#642callback编程模型)
            - [6.4.3Actor编程模型](#643actor编程模型)
            - [6.4.4CSP编程模型](#644csp编程模型)
    - [常见面试题](#常见面试题)

<!-- /TOC -->

## 1.进程

- 进程是一个实体，每一个进程有自己的地址空间（`文本区域(text region)`，`数据区域(data region)`，`堆栈(stack region)`）
  - 文本区域：存储处理器执行的代码
  - 数据区域：存储变量和动态分配的内存
  - 堆栈区域：存储活动过程调用的指令和本地变量
- 进程是一个`执行中的程序`

*进程切换*（或上下文切换）就是`从正在运行的进程中收回处理器，用新的进程塞进处理器，同时切换虚拟内存空间`;
*线程切换*与进程切换的区别就是线程切换不会切换虚拟内存空间。

**进程间通信**：

1. 消息传递（`管道`，`FIFO`，`消息队列(MQ)`）
2. 同步(`互斥量`，`条件变量`，`读写锁`，`文件和写记录锁`，`信号量`)
3. 共享内存(`匿名的`，`具名的`)
4. 远程过程调用(`RPC`)

## 2.线程

- 轻量级线程，程序执行流的最小单位
- 可以并发执行
- 共享进程资源，所有的线程享有所属进程的共同地址空间

## 3.协程

- 微线程，或者用户级线程，是一个执行单元，自带CPU上下文
- 与线程的区别就是`线程是抢占式调用，协程是调度式调用(用户控制)`
- 没有线程的使用多CPU的能力

一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外的一个函数。

## 4.内存管理

### 4.1栈

- 连续的一块内存区域
- 用于存放本地变量，内部临时变量以及与上下文有关的内容
- 机器系统提供，有底层的支持，效率较高

### 4.2堆

- 存放不在栈里的数据，coder控制，容易产生`内存泄漏(Memory Leak)，内存的使用超过分配的最大值`[面试内存泄露问题](https://blog.csdn.net/zy_jibai/article/details/80957169)

### 4.3内存抖动

内存频繁的分配和回收导致卡顿，甚至会发生内存泄漏。

## 5.磁盘

### 5.1磁盘调度

磁盘访问延迟 = 队列时间 + 控制器时间 + `寻道时间(主要耗时)` + 旋转时间 + 传输时间

## 6.高并发

`高并发`指的是系统能够同时并行处理多个请求。

参考:

- [Python高并发详解](https://www.cnblogs.com/daofaziran/p/10154986.html)

### 6.1提升系统并发能力

1. 垂直扩展
   1. 增加单机硬件性能,更好的cpu, ssd, 更大的内存
   2. 提升单机架构性能，减少cache来减少IO次数，使用异步来增加单服务吞吐量
2. 水平扩展
   1. 增加服务器的数量
   2. 反向代理层：通过DNS轮询，`dns-server对于一个域名配置多个解析ip,每次DNS解析请求来访问dns-server，会轮询返回ip`
   3. 站点层：通过`改nginx.conf，配置多个web后端`
   4. 服务层：通过`服务连接池`实现，站点层的RPC-client与下游服务建立多个连接，服务成为瓶颈的时候，只要增加服务器数量即可
   5. 数据层：`主从同步`等

### 6.2高并发指标

- 响应时间
- 吞吐量
- 每秒查询率
- 并发用户数

### 6.3python解决高并发

1. HTML页面静态化
2. 图片服务器分离
3. 使用缓存(使用redis作为缓存的数据库)
4. 数据库集群，库表散列
5. 使用负载均衡
6. 镜像网站，CDN加速等

```nginx
<!-- 简单的负载均衡nginx配置 -->
upstream myserver {
    server 192.168.72.49:8080;
    server 192.168.72.49:8081;
}
```

### 6.4并发模型

#### 6.4.1多线程编程模型

**特点**：

- 多个相互独立的执行流
- 共享内存
- 抢占式调度
- 依赖锁，信号量等同步机制

**易出现问题**：

- 死锁，活锁
- 资源耗尽
- 优先级反转

#### 6.4.2Callback编程模型

- 常常用于`异步事件`
- 函数A在函数B没有被调用的情况下就先返回结果，在某个异步事件发生时候再执行回调函数

#### 6.4.3Actor编程模型

- 属于并发组件模型
- 区别于传统多线程之间通过共享内存和同步机制来防止写争夺，Actors使用消息模型
- 每个Actors在同一时间只处理一个消息，可以发送消息到其他的Actors，保证了单独写，避免多线程的资源争夺

#### 6.4.4CSP编程模型

- 分为两个模块：`Processor`(代表任务执行的顺序单元，内部无并发)和`Channel`(代表信息流之间的信息交互，如共享数据的交换，修改等)
- Processor之间解耦合，工作者之间不直接通信，工作者向不同的通道中发送消息，其他工作者监听这些通道的消息

## 常见面试题
